<?php

/*
 * This file is part of Arakne-Swf.
 *
 * Arakne-Swf is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * Arakne-Swf is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with Arakne-Swf.
 * If not, see <https://www.gnu.org/licenses/>.
 *
 * Copyright (C) 2024 Vincent Quatrevieux (quatrevieux.vincent@gmail.com)
 */

declare(strict_types=1);

namespace Arakne\Swf\Extractor\Timeline;

use Arakne\Swf\Extractor\DrawableInterface;
use Arakne\Swf\Extractor\Drawer\DrawerInterface;
use Arakne\Swf\Extractor\Modifier\CharacterModifierInterface;
use Arakne\Swf\Parser\Structure\Record\ColorTransform;
use Arakne\Swf\Parser\Structure\Record\Rectangle;
use Arakne\Swf\Parser\Structure\Tag\DoActionTag;
use Override;

use function ksort;

/**
 * Represent a single from of a timeline
 */
final readonly class Frame implements DrawableInterface
{
    public function __construct(
        /**
         * The display rectangle of the frame
         * It should be the same for all frames of the timeline
         */
        public Rectangle $bounds,

        /**
         * Objects to displayed, ordered by depth
         *
         * @var array<int, FrameObject>
         */
        public array $objects,

        /**
         * Script actions associated with this frame
         *
         * @var list<DoActionTag>
         */
        public array $actions = [],

        /**
         * The frame label.
         * Can be use by the action go to label to jump to this frame.
         */
        public ?string $label = null,
    ) {}

    #[Override]
    public function bounds(): Rectangle
    {
        return $this->bounds;
    }

    #[Override]
    public function framesCount(bool $recursive = false): int
    {
        if (!$recursive) {
            return 1;
        }

        $count = 1;

        foreach ($this->objects as $object) {
            $objectFramesCount = $object->object->framesCount(true);

            if ($objectFramesCount > $count) {
                $count = $objectFramesCount;
            }
        }

        return $count;
    }

    #[Override]
    public function draw(DrawerInterface $drawer, int $frame = 0): DrawerInterface
    {
        $drawer->area($this->bounds);

        /**
         * Map of active clip ids. The value is the depth of the clip,
         * and the key is the id of the clip generated by the drawer.
         *
         * @var array<string, int> $activeClips
         */
        $activeClips = [];

        foreach ($this->objects as $object) {
            if ($object->clipDepth !== null) {
                $id = $drawer->startClip($object->object, $object->matrix, $frame);
                $activeClips[$id] = $object->clipDepth;

                continue;
            }

            foreach ($activeClips as $id => $depth) {
                if ($depth < $object->depth) {
                    $drawer->endClip($id);
                    unset($activeClips[$id]);
                }
            }

            $drawer->include(
                $object->transformedObject(),
                $object->matrix,
                $frame,
                $object->filters,
                $object->blendMode,
                $object->name,
            );
        }

        return $drawer;
    }

    #[Override]
    public function transformColors(ColorTransform $colorTransform): self
    {
        $objects = [];

        foreach ($this->objects as $depth => $object) {
            $objects[$depth] = $object->transformColors($colorTransform);
        }

        return new self(
            $this->bounds,
            $objects,
            $this->actions,
            $this->label
        );
    }

    /**
     * Get an object by its name
     *
     * @param string $name The name of the object
     * @return FrameObject|null The object if found, null otherwise
     */
    public function objectByName(string $name): ?FrameObject
    {
        foreach ($this->objects as $object) {
            if ($object->name === $name) {
                return $object;
            }
        }

        return null;
    }

    #[Override]
    public function modify(CharacterModifierInterface $modifier, int $maxDepth = -1): Frame
    {
        $self = $this;

        if ($maxDepth !== 0) {
            $objects = [];
            $isModified = false;

            $xmin = $this->bounds->xmin;
            $ymin = $this->bounds->ymin;
            $xmax = $this->bounds->xmax;
            $ymax = $this->bounds->ymax;

            foreach ($this->objects as $depth => $object) {
                $newObject = $object->object->modify($modifier, $maxDepth - 1);

                if ($newObject === $object->object) {
                    $objects[$depth] = $object;
                    continue;
                }

                $isModified = true;
                $oldObjectBounds = $object->object->bounds();
                $oldMatrix = $object->matrix->translate(-$oldObjectBounds->xmin, -$oldObjectBounds->ymin);

                $objects[$depth] = $object->with(
                    object: $newObject,
                    bounds: $newBounds = $newObject->bounds()->transform($oldMatrix),
                    matrix: $oldMatrix->translate($newObject->bounds()->xmin, $newObject->bounds()->ymin),
                );

                if ($newBounds->xmin < $xmin) {
                    $xmin = $newBounds->xmin;
                }
                if ($newBounds->ymin < $ymin) {
                    $ymin = $newBounds->ymin;
                }
                if ($newBounds->xmax > $xmax) {
                    $xmax = $newBounds->xmax;
                }
                if ($newBounds->ymax > $ymax) {
                    $ymax = $newBounds->ymax;
                }
            }

            if ($isModified) {
                $self = new self(
                    new Rectangle($xmin, $xmax, $ymin, $ymax),
                    $objects,
                    $this->actions,
                    $this->label
                );
            }
        }

        return $modifier->applyOnFrame($self);
    }

    /**
     * Modify the bounds of the frame.
     * This method allow to keep the same bounds on all frames on the sprite.
     *
     * @param Rectangle $newBounds
     * @return self
     */
    public function withBounds(Rectangle $newBounds): self
    {
        return new self(
            $newBounds,
            $this->objects,
            $this->actions,
            $this->label
        );
    }

    /**
     * Recompute the bounds of the frame based on its objects
     * This is useful when you want to extract the frame from a timeline and want to have correct bounds
     *
     * @return self
     */
    public function compact(): self
    {
        return new self(
            Rectangle::merge(
                array_map(
                    static fn (FrameObject $object) => $object->bounds,
                    $this->objects
                )
            ),
            $this->objects,
            $this->actions,
            $this->label
        );
    }

    /**
     * Add a new object to the frame at its depth, and return a new frame with updated bounds
     * The timeline bounds should be updated accordingly
     *
     * Note: If an object already exists at the same depth, it will be replaced silently.
     *
     * @param FrameObject $object
     * @return self The new frame with the added object
     */
    public function addObject(FrameObject $object): self
    {
        $objects = $this->objects;
        $objects[$object->depth] = $object;
        ksort($objects);
        $bounds = $this->bounds->union($object->bounds);

        return new self(
            $bounds,
            $objects,
            $this->actions,
            $this->label
        );
    }
}
